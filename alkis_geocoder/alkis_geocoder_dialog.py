# -*- coding: utf-8 -*-
"""
/***************************************************************************
 AlkisGeocoderDialog
                                 A QGIS plugin
 Adress Geocoding using an ALKIS database
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2019-06-26
        git sha              : $Format:%H$
        copyright            : (C) 2019 by Geoinformatikb√ºro Dassau GmbH
        email                : info@gbd-consult.de
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os

from PyQt5 import uic, QtWidgets
from PyQt5.QtCore import QSettings, QVariant
from qgis.core import QgsDataSourceUri, QgsField, QgsProject, QgsVectorLayer, QgsGeometry, QgsPointXY
import db_manager.db_plugins.postgis.connector as con

# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'alkis_geocoder_dialog_base.ui'))


class AlkisGeocoderDialog(QtWidgets.QDialog, FORM_CLASS):
    def __init__(self, parent=None):
        """Constructor."""
        super(AlkisGeocoderDialog, self).__init__(parent)
        # Set up the user interface from Designer through FORM_CLASS.
        # After self.setupUi() you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://qt-project.org/doc/qt-4.8/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)

        # initialize the DB connection combobox
        self.qgsSettings = QSettings()
        self.qgsSettings.beginGroup('/PostgreSQL/connections/')
        connections = self.qgsSettings.childGroups()
        self.qgsSettings.endGroup()
        self.dbComboBox.addItems(connections)

        self.layerChange(self.tableLayer.currentLayer())

        self.tableLayer.layerChanged.connect(self.layerChange)
        self.generateLayerButton.clicked.connect(self.generateLayer)


    def layerChange(self,layer):
        self.streetField.setLayer(layer)
        self.numberField.setLayer(layer)
        self.cityField.setLayer(layer)


    def getConnection(self):
        conName = self.dbComboBox.currentText()
        self.qgsSettings.beginGroup('/PostgreSQL/connections/')
        userName = self.qgsSettings.value('/%s/username/' % conName)
        host = self.qgsSettings.value('/%s/host/' % conName)
        port = self.qgsSettings.value('/%s/port/' % conName)
        password = self.qgsSettings.value('/%s/password/' % conName)
        database = self.qgsSettings.value('/%s/database/' % conName)
        self.qgsSettings.endGroup()
        uri = QgsDataSourceUri()
        uri.setConnection(host, port, database, userName, password)
        c = con.PostGisDBConnector(uri)
        return(c)


    def geocode(self, connection, feature):
        """ geocodes a QgsFeature.
        Args:
            connection (PostGisDBConnector): Connection to postgis db.
            feature (QgsFeature): feature being geocodes.
        """
        def removeSpace(qv):
            try:
                res = str(qv).strip()
                if res == 'NULL':
                    return False
                else:
                    return res
            except:
                return False

        strasse = removeSpace(feature[self.streetField.currentField()])
        hausnummer = removeSpace(feature[self.numberField.currentField()])
        gemeinde = removeSpace(feature[self.cityField.currentField()])
        if strasse and hausnummer and gemeinde:
            query = "SELECT * FROM gws_adressen_no_plz AS a WHERE UPPER(a.strasse) = UPPER(\'%s\') AND UPPER(a.hausnummer) = UPPER(\'%s\') AND UPPER(a.gemeinde) LIKE UPPER(\'%s%%\')" % (strasse, hausnummer, gemeinde)
            x = connection._execute(None, query)
            data = connection._fetchall(x)
            if data:
                x = data[0][5]
                y = data[0][6]
                feature.setAttribute('lat', x)
                feature.setAttribute('lon', y)
                geom = QgsPointXY(x, y)
                feature.setGeometry(QgsGeometry.fromPointXY(geom))
            else:
                print(query)


    def generateLayer(self):
        """ The main function, that does all the geocoding work. """
        try:
            connection = self.getConnection()
        except:
            return False

        # create new memory layer
        layer = self.tableLayer.currentLayer()
        features = [f for f in layer.getFeatures()]
        mem_layer = QgsVectorLayer("Point?crs=epsg:4326", "geocoded_layer", "memory")
        mem_layer_data = mem_layer.dataProvider()
        attr = layer.dataProvider().fields().toList()
        mem_layer_data.addAttributes(attr + [QgsField('lat', QVariant.Double), QgsField('lon', QVariant.Double)])
        mem_layer.updateFields()
        mem_layer_data.addFeatures(features)
        mem_layer.startEditing()
        for f in mem_layer.getFeatures():
            self.geocode(connection, f)
            mem_layer.updateFeature(f)
        mem_layer.commitChanges()

        QgsProject.instance().addMapLayer(mem_layer)
