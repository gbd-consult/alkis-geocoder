# -*- coding: utf-8 -*-
"""
/***************************************************************************
 AlkisGeocoderDialog
                                 A QGIS plugin
 Adress Geocoding using an ALKIS database
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2019-06-26
        git sha              : $Format:%H$
        copyright            : (C) 2019 by Geoinformatikbüro Dassau GmbH
        email                : info@gbd-consult.de
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os
from qgis.utils import iface
from PyQt5 import uic, QtWidgets
from PyQt5.QtCore import QSettings, QVariant
from qgis.core import QgsDataSourceUri, QgsField, QgsProject, QgsVectorLayer, QgsGeometry, QgsPointXY
import db_manager.db_plugins.postgis.connector as con

# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'alkis_geocoder_dialog_base.ui'))


class AlkisGeocoderDialog(QtWidgets.QDialog, FORM_CLASS):
    def __init__(self, parent=None):
        """Constructor."""
        super(AlkisGeocoderDialog, self).__init__(parent)
        # Set up the user interface from Designer through FORM_CLASS.
        # After self.setupUi() you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://qt-project.org/doc/qt-4.8/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)

        # initialize the DB connection combobox
        self.qgsSettings = QSettings()
        self.qgsSettings.beginGroup('/PostgreSQL/connections/')
        connections = self.qgsSettings.childGroups()
        self.qgsSettings.endGroup()
        self.dbComboBox.addItems(connections)

        if not (self.tableLayer.currentLayer() and self.dbComboBox.currentText()):
            self.generateLayerButton.setEnabled(False)

        self.onLayerChange(self.tableLayer.currentLayer())

        # only show delimitedtext layers
        excepted = []
        for layer in QgsProject.instance().mapLayers().values():
            if hasattr(layer, 'providerType') and layer.providerType() != 'delimitedtext':
                excepted.append(layer)
        self.tableLayer.setExceptedLayerList(excepted)

        self.tableLayer.layerChanged.connect(self.onLayerChange)
        self.dbComboBox.currentTextChanged.connect(self.onDbChange)
        self.generateLayerButton.clicked.connect(self.generateLayer)

        QgsProject.instance().layerWasAdded.connect(self.onLayerAdd)


    def onLayerAdd(self, layer):
        """ gets run, when a layer gets added to the Qgis Project."""
        if hasattr(layer, 'providerType') and layer.providerType() != 'delimitedtext':
            excepted = self.tableLayer.exceptedLayerList()
            excepted.append(layer)
            self.tableLayer.setExceptedLayerList(excepted)


    def onDbChange(self):
        """ gets run when the active database connection in the QCombobox changes."""
        if self.tableLayer.currentLayer() and self.dbComboBox.currentText():
            self.generateLayerButton.setEnabled(True)


    def onLayerChange(self,layer):
        """ gets run, when the active layer of the QgsMapLayerCombobox changes."""
        if self.tableLayer.currentLayer() and self.dbComboBox.currentText():
            self.generateLayerButton.setEnabled(True)

        self.streetField.setLayer(layer)
        self.numberField.setLayer(layer)
        self.cityField.setLayer(layer)


    def getConnection(self):
        """ establishes a DB connection. """
        conName = self.dbComboBox.currentText()
        self.qgsSettings.beginGroup('/PostgreSQL/connections/')
        userName = self.qgsSettings.value('/%s/username/' % conName)
        host = self.qgsSettings.value('/%s/host/' % conName)
        port = self.qgsSettings.value('/%s/port/' % conName)
        password = self.qgsSettings.value('/%s/password/' % conName)
        database = self.qgsSettings.value('/%s/database/' % conName)
        self.qgsSettings.endGroup()
        uri = QgsDataSourceUri()
        uri.setConnection(host, port, database, userName, password)
        c = con.PostGisDBConnector(uri)
        return(c)


    def geocode(self, connection, feature):
        """ geocodes a QgsFeature.
        Args:
            connection (PostGisDBConnector): Connection to postgis db.
            feature (QgsFeature): feature being geocodes.
        """
        def removeSpace(qv):
            try:
                # pythons upper() function replaces 'ß' with 'SS'. This means we don't need to replace 'ß' here.
                res = str(qv).strip().upper().replace('Ä','AE').replace('Ü','UE').replace('Ö','OE').replace('-','').replace(' ','')
                if res.endswith('STR.'):
                    res = res.replace('STR.','STRASSE')
                if res == 'NULL':
                    return False
                else:
                    return res
            except:
                return False

        strasse = removeSpace(feature[self.streetField.currentField()])
        hausnummer = removeSpace(feature[self.numberField.currentField()])
        gemeinde = removeSpace(feature[self.cityField.currentField()])
        if strasse and hausnummer and gemeinde:
            query = "SELECT * FROM gws_adressen_no_plz AS a WHERE a.strasse = \'%s\' AND a.hausnummer = \'%s\' AND a.gemeinde LIKE \'%s%%\'" % (strasse, hausnummer, gemeinde)
            x = connection._execute(None, query)
            data = connection._fetchall(x)
            if data:
                x = data[0][5]
                y = data[0][6]
                feature.setAttribute('lat', x)
                feature.setAttribute('lon', y)
                geom = QgsPointXY(x, y)
                feature.setGeometry(QgsGeometry.fromPointXY(geom))


    def generateLayer(self):
        """ The main function, that does all the geocoding work. """
        try:
            connection = self.getConnection()
        except:
            return False

        # create new memory layer
        layer = self.tableLayer.currentLayer()
        features = [f for f in layer.getFeatures()]
        mem_layer = QgsVectorLayer('Point?crs=epsg:25832', '%s_geocoded' % layer.name(), 'memory')
        mem_layer_data = mem_layer.dataProvider()
        attr = layer.dataProvider().fields().toList()
        mem_layer_data.addAttributes(attr + [QgsField('lat', QVariant.Double), QgsField('lon', QVariant.Double)])
        mem_layer.updateFields()
        mem_layer_data.addFeatures(features)
        mem_layer.startEditing()
        for f in mem_layer.getFeatures():
            self.geocode(connection, f)
            mem_layer.updateFeature(f)
        geom_features = len(list(filter(lambda x: x.hasGeometry(),[f for f in mem_layer.getFeatures()])))
        if geom_features > 0:
            iface.messageBar().pushSuccess('Geocodierung abgeschlossen', '%s von %s Features konnten geocodiert werden' % (geom_features, layer.featureCount()))
        else:
            iface.messageBar().pushCritical('Geocodierung fehlgeschlagen', 'Es konnten keine Features geocodiert werden.')
        mem_layer.commitChanges()

        QgsProject.instance().addMapLayer(mem_layer)
